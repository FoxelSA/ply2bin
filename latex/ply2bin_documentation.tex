\documentclass[a4paper, 11pt]{article}

%========================================================================
%
%       Packages inclusion
%
% =======================================================================

%\usepackage{../preambule}
\usepackage[latin1]{inputenc}
\usepackage[french]{babel}
\usepackage{amsmath}
%\usepackage{bbm}
\usepackage{lscape}
\usepackage{inputenc}
%\usepackage[refpage,french,noprefix]{nomencl}
\usepackage{lmodern}
\usepackage{url}
\usepackage{float, graphicx}
\usepackage[sectionbib]{chapterbib}

\author{ St\'ephane Flotron }
\title{\textbf{ply2bin documentation}}

% definition of useful command for the document
\renewcommand{\tilde}{\widetilde}
\renewcommand{\t}{\mathbf{t}}

%========================================================================
%
%       Document 
%
% =======================================================================
\begin{document}

   \maketitle
   
   \section*{Program description}
   
   The ply2bin software is a program which convert a point cloud in PLY file format into 
   a binary file readable for the DAV interface. 
   The keypoint of this sofware is to transform the (aligned) point cloud into the WebGL
   interface associated to the panorama.
   
   \section*{Mathematics}
   
   Suppose that we have an aligned point cloud in CH1903+ referential, and that we want to transform the points into
   the WebGL interface. In order to simplify the reading, let us introduce some notations. 
   
   \begin{table}[H]
      \begin{center}
        \begin{tabular}{|c|l|}
                \hline 
                    Notation & description \\
                \hline
                    $X_{CH1903}$ & 3D point in MN95 referential frame \\
                    $X_S$       & 3D point in shifted MN95 referential frame \\
                    $X_{abs}$   & 3D point in SfM referential frame \\
                    $X_{trans}$ & 3D point in rigidly transformed openMVG referential frame \\
                    $X_r$       & 3D point in openMVG referential frame \\
                    $X_c$       & 3D point in camera referential frame \\
                    $X_{pix}$   & 3D point in camera pixel coordinate frame \\
                \hline
        \end{tabular}
      \end{center}
      \label{3D point notation}
      \caption{Notions for 3D points in different referential frames}
   \end{table}
   
   The notation define above are related to each other with the following relations :
   \begin{equation}
       X_{CH1903}  = s R_a ( X_{trans} - C_a ) + S \Leftrightarrow X_{trans} = \frac{1}{s} R_a^T ( X_{CH1903} -S ) + C_a
   \end{equation}
   where $s$ is the scale factor used to retreive metric coordinates, $R_a$ is the rotation matrix used to align
   point cloud, $C_a$ is the center of rotation in CH1903+ referential frame and $S$ is a shift to have a precise
   point cloud rendering. However, the store point cloud is ofter $X_{CH1903}-S$, so the above transformation become
   \begin{equation}
       X_{S}  = s R_a ( X_{trans} - C_a ) \Leftrightarrow X_{trans} = \frac{1}{s} R_a^T ( X_{S} + C_a )
   \end{equation}
   and we only need to take $S$ into account for exportation of true CH1903 coordinates (and not for the projection part).
   Moreover, if a rigid transformation is applied to the point cloud generated by openMVG, 
   $X_{trans}$ and $X_{abs}$ are related by the following relation :
   \begin{equation}
       X_{trans} = R_2 X_{abs} + \t_2 \Leftrightarrow X_{abs} = R_2^T (X_{trans} - \t_2).
   \end{equation}
   where $R_2$ is a rotation matrix and $\t_2$ is a translation. Generally, no transformation is applied on the point
   cloud, so if not provided, the default value of $R_2$ and $\t_2$ are $I_3$ and $0$ respectively. 
   Finally, the coordinates of the 3d point in the pose referential frame is given by
   \begin{equation}
       X_r = R_r (X_{abs}-C_r).
   \end{equation}
   where $(R_r, C_r)$ is the pose of the panorama in openMVG referential frame. 
   Note that $R_r$ is a rotation matrix and $C_r$ is the center of the eyesis in openMVG referential frame. 
   The final application we need to have the full transformation is the transformation between a point $X_r$ in the pose referential 
   frame to the webGL coordinates frame, which is simply given by
   \begin{equation}
       X_{wgl} = R_x(\pi) X_r
   \end{equation}
   where $R_x(\pi)$ is simply a rotation of angle $\pi$ around the $x$-axis. Combining those relations together, the transformation 
   from the shifted aligned referential frame to the WebGL coordinate frame is then 
   \begin{equation}
       \begin{aligned}
           & X_{wgl} & = & \frac{1}{s} R_x(\pi) R_r R_2^T R_a^T X_S + \frac{1}{s} R_x(\pi) R_r R_2^T C_a \\
            &&&       -R_x(\pi) R_r R_2^T \t_2 - R_x(\pi) R_r C_r.
       \end{aligned}
   \end{equation} 
   Let us define $\overline X $ as the 3D you need for projection onto panorama, and $\tilde X$ the 3D point you need 
   for measurments. Then 
   \begin{equation}
        \begin{aligned}
        \overline X & = && R_x(\pi) X_{wgl} \\
        \tilde X & = && s X_{wgl}
        \end{aligned}
   \end{equation}
   which is equivalent to 
      \begin{equation}
        \begin{aligned}
        \overline X = X_r & = && \frac{1}{s} R_r R_2^T R_a^T X_S + \frac{1}{s} R_r R_2^T C_a -R_r R_2^T \t_2 - R_r C_r. \\
        \tilde X & = && R_x(\pi) R_r R_2^T R_a^T X_S + R_x(\pi) R_r R_2^T C_a \\
            &&&       -s R_x(\pi) R_r R_2^T \t_2 - s R_x(\pi) R_r C_r.
        \end{aligned}
   \end{equation}
   Then, to obtain the coordinate in local sensor coordinates, you only need to apply the pose $(R_c, C_c)$ of the
   channel $c$ to a point $X_r$ in the pose referential coordinate frame. This is given by the following application
   \begin{equation}
       X_c = R_c (X_r - C_c).
   \end{equation}
   Denoting by $K_c$ the camera matrix, $P^i$ the i-nth coordinate of a point $P$, 
   the projection of the point $X_r$ in pixels coordinate frame of channel $c$ is given by
   \begin{equation}
        X_{pix}^i = (K_c X_c)^i / X_{c}^3 \qquad i=1,2.
   \end{equation}
   which is equivalent to 
   \begin{equation}
        X_{pix}^i = ( K_c R_c X_r - K_c R_c C_c )^i / ( K_c R_c X_r - K_c R_c C_c )^3, \qquad i=1,2.
   \end{equation}


\end{document}